.TH "frontend" 3 "Sun Jan 24 2016" "Version 1.10.0" "libdvbv5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
frontend \- Digital TV frontend control
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBdvb\-fe\&.h\fP"
.br
.RI "\fIProvides interfaces to deal with DVB frontend\&. \fP"
.ti -1c
.RI "file \fBdvb\-v5\-std\&.h\fP"
.br
.RI "\fIProvides libdvbv5 defined properties for the frontend\&. \fP"
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP"
.br
.RI "\fIKeeps data needed to handle the DVB frontend\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBMAX_DELIVERY_SYSTEMS\fP"
.br
.RI "\fIMax number of delivery systems for a given frontend\&. \fP"
.ti -1c
.RI "#define \fBDTV_USER_COMMAND_START\fP"
.br
.RI "\fIStart number for libdvbv5 user commands\&. \fP"
.ti -1c
.RI "#define \fBDTV_POLARIZATION\fP"
.br
.RI "\fISatellite polarization (for Satellite delivery systems) \fP"
.ti -1c
.RI "#define \fBDTV_AUDIO_PID\fP"
.br
.RI "\fIAudio PID\&. \fP"
.ti -1c
.RI "#define \fBDTV_VIDEO_PID\fP"
.br
.RI "\fIVideo PID\&. \fP"
.ti -1c
.RI "#define \fBDTV_SERVICE_ID\fP"
.br
.RI "\fIMPEG TS service ID\&. \fP"
.ti -1c
.RI "#define \fBDTV_CH_NAME\fP"
.br
.RI "\fIDigital TV service name\&. \fP"
.ti -1c
.RI "#define \fBDTV_VCHANNEL\fP"
.br
.RI "\fIDigital TV channel number\&. \fP"
.ti -1c
.RI "#define \fBDTV_SAT_NUMBER\fP"
.br
.RI "\fINumber of the satellite (used on multi-dish Satellite systems) \fP"
.ti -1c
.RI "#define \fBDTV_DISEQC_WAIT\fP"
.br
.RI "\fIExtra time needed to wait for DiSeqC to complete, in ms\&. \fP"
.ti -1c
.RI "#define \fBDTV_DISEQC_LNB\fP"
.br
.RI "\fILNBf name\&. \fP"
.ti -1c
.RI "#define \fBDTV_FREQ_BPF\fP"
.br
.RI "\fISCR/Unicable band-pass filter frequency in kHz\&. \fP"
.ti -1c
.RI "#define \fBDTV_PLS_CODE\fP"
.br
.RI "\fIDVB-T2 PLS code\&. \fP"
.ti -1c
.RI "#define \fBDTV_PLS_MODE\fP"
.br
.RI "\fIDVB-T2 PLS mode\&. \fP"
.ti -1c
.RI "#define \fBDTV_COUNTRY_CODE\fP"
.br
.RI "\fICountry variant of international delivery system standard\&. \fP"
.ti -1c
.RI "#define \fBDTV_MAX_USER_COMMAND\fP"
.br
.RI "\fILast user command\&. \fP"
.ti -1c
.RI "#define \fBDTV_USER_NAME_SIZE\fP"
.br
.RI "\fINumber of user commands\&. \fP"
.ti -1c
.RI "#define \fBDTV_STAT_COMMAND_START\fP"
.br
.RI "\fIStart number for libdvbv5 statistics commands\&. \fP"
.ti -1c
.RI "#define \fBDTV_STATUS\fP"
.br
.RI "\fILock status of a DTV frontend\&. \fP"
.ti -1c
.RI "#define \fBDTV_BER\fP"
.br
.RI "\fIBit Error Rate\&. \fP"
.ti -1c
.RI "#define \fBDTV_PER\fP"
.br
.RI "\fIPacket Error Rate\&. \fP"
.ti -1c
.RI "#define \fBDTV_QUALITY\fP"
.br
.RI "\fIA quality indicator that represents if a locked channel provides a good, OK or poor signal\&. \fP"
.ti -1c
.RI "#define \fBDTV_PRE_BER\fP"
.br
.RI "\fIBit Error Rate before Viterbi\&. \fP"
.ti -1c
.RI "#define \fBDTV_MAX_STAT_COMMAND\fP"
.br
.RI "\fILast statistics command\&. \fP"
.ti -1c
.RI "#define \fBDTV_STAT_NAME_SIZE\fP"
.br
.RI "\fINumber of statistics commands\&. \fP"
.ti -1c
.RI "#define \fBDTV_NUM_KERNEL_STATS\fP"
.br
.RI "\fINumber of statistics commands provided by the Kernel\&. \fP"
.ti -1c
.RI "#define \fBDTV_NUM_STATS_PROPS\fP"
.br
.RI "\fITotal number of statistics commands\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBdvb_quality\fP { \fBDVB_QUAL_UNKNOWN\fP, \fBDVB_QUAL_POOR\fP, \fBDVB_QUAL_OK\fP, \fBDVB_QUAL_GOOD\fP }
.RI "\fIProvides an estimation about the user's experience while watching to a given MPEG stream\&. \fP""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_dummy\fP (void)"
.br
.RI "\fIAllocates a dummy frontend structure\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_open_flags\fP (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call, \fBdvb_logfunc\fP logfunc, int flags)"
.br
.RI "\fIOpens a frontend and allocates a structure to work with\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_open\fP (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call)"
.br
.RI "\fIOpens a frontend and allocates a structure to work with\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_open2\fP (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call, \fBdvb_logfunc\fP logfunc)"
.br
.RI "\fIOpens a frontend and allocates a structure to work with\&. \fP"
.ti -1c
.RI "void \fBdvb_fe_close\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fICloses the frontend and frees allocated resources\&. \fP"
.ti -1c
.RI "const char * \fBdvb_cmd_name\fP (int cmd)"
.br
.RI "\fIReturns the string name associated with a DVBv5 command\&. \fP"
.ti -1c
.RI "const char *const * \fBdvb_attr_names\fP (int cmd)"
.br
.RI "\fIReturns an string array with the valid string values associated with a DVBv5 command\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_retrieve_parm\fP (const struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, uint32_t *value)"
.br
.RI "\fIRetrieves the value of a DVBv5/libdvbv5 property\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_store_parm\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, uint32_t value)"
.br
.RI "\fIStores the value of a DVBv5/libdvbv5 property\&. \fP"
.ti -1c
.RI "int \fBdvb_set_sys\fP (struct \fBdvb_v5_fe_parms\fP *parms, fe_delivery_system_t sys)"
.br
.RI "\fISets the delivery system\&. \fP"
.ti -1c
.RI "int \fBdvb_add_parms_for_sys\fP (struct \fBdvb_v5_fe_parms\fP *parms, fe_delivery_system_t sys)"
.br
.RI "\fIMake dvb properties reflect the current standard\&. \fP"
.ti -1c
.RI "int \fBdvb_set_compat_delivery_system\fP (struct \fBdvb_v5_fe_parms\fP *parms, uint32_t desired_system)"
.br
.RI "\fISets the delivery system\&. \fP"
.ti -1c
.RI "void \fBdvb_fe_prt_parms\fP (const struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIPrints all the properties at the cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_set_parms\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIPrints all the properties at the cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_get_parms\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIPrints all the properties at the cache\&. \fP"
.ti -1c
.RI "struct dtv_stats * \fBdvb_fe_retrieve_stats_layer\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, unsigned layer)"
.br
.RI "\fIRetrieve the stats for a DTV layer from cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_retrieve_stats\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, uint32_t *value)"
.br
.RI "\fIRetrieve the stats for a DTV layer from cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_get_stats\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIRetrieve the stats from the Kernel\&. \fP"
.ti -1c
.RI "float \fBdvb_fe_retrieve_ber\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned layer, enum fecap_scale_params *scale)"
.br
.RI "\fIRetrieve the BER stats from cache\&. \fP"
.ti -1c
.RI "float \fBdvb_fe_retrieve_per\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned layer)"
.br
.RI "\fIRetrieve the PER stats from cache\&. \fP"
.ti -1c
.RI "enum \fBdvb_quality\fP \fBdvb_fe_retrieve_quality\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned layer)"
.br
.RI "\fIRetrieve the quality stats from cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_snprintf_eng\fP (char *buf, int len, float val)"
.br
.RI "\fIAncillary function to sprintf on ENG format\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_snprintf_stat\fP (struct \fBdvb_v5_fe_parms\fP *parms, uint32_t cmd, char *display_name, int layer, char **buf, int *len, int *show_layer_name)"
.br
.RI "\fIAncillary function to sprintf on ENG format\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_get_event\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIGet both status statistics and dvb parameters\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_sec_voltage\fP (struct \fBdvb_v5_fe_parms\fP *parms, int on, int v18)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC voltage\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_sec_tone\fP (struct \fBdvb_v5_fe_parms\fP *parms, fe_sec_tone_mode_t tone)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC tone\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_lnb_high_voltage\fP (struct \fBdvb_v5_fe_parms\fP *parms, int on)"
.br
.RI "\fIDVB ioctl wrapper for setting LNBf high voltage\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_diseqc_burst\fP (struct \fBdvb_v5_fe_parms\fP *parms, int mini_b)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC DiSeqC tone burst to select between satellite A or B\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_diseqc_cmd\fP (struct \fBdvb_v5_fe_parms\fP *parms, const unsigned len, const unsigned char *buf)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC DiSeqC command\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_diseqc_reply\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned *len, char *buf, int timeout)"
.br
.RI "\fIDVB ioctl wrapper for getting SEC DiSEqC reply\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_is_satellite\fP (uint32_t delivery_system)"
.br
.RI "\fIDVB Ancillary routine to check if a given Delivery system is satellite\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_set_default_country\fP (struct \fBdvb_v5_fe_parms\fP *parms, const char *country)"
.br
.RI "\fISet default country variant of delivery systems like ISDB-T\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Macro Definition Documentation"
.PP 
.SS "#define DTV_AUDIO_PID"

.PP
Audio PID\&. 
.PP
Definition at line 112 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_BER"

.PP
Bit Error Rate\&. This is a parameter that it is derivated from two counters at the Kernel side 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Definition at line 201 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_CH_NAME"

.PP
Digital TV service name\&. 
.PP
Definition at line 114 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_COUNTRY_CODE"

.PP
Country variant of international delivery system standard\&. in ISO 3166-1 two letter code\&. 
.PP
Definition at line 122 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_DISEQC_LNB"

.PP
LNBf name\&. 
.PP
Definition at line 118 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_DISEQC_WAIT"

.PP
Extra time needed to wait for DiSeqC to complete, in ms\&. The minimal wait time is 15 ms\&. The time here will be added to the minimal time\&. 
.PP
Definition at line 117 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_FREQ_BPF"

.PP
SCR/Unicable band-pass filter frequency in kHz\&. 
.PP
Definition at line 119 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_MAX_STAT_COMMAND"

.PP
Last statistics command\&. 
.PP
Definition at line 206 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_MAX_USER_COMMAND"

.PP
Last user command\&. 
.PP
Definition at line 124 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_NUM_KERNEL_STATS"

.PP
Number of statistics commands provided by the Kernel\&. 
.PP
Definition at line 211 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_NUM_STATS_PROPS"

.PP
Total number of statistics commands\&. 
.PP
Definition at line 213 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_PER"

.PP
Packet Error Rate\&. This is a parameter that it is derivated from two counters at the Kernel side 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Definition at line 202 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_PLS_CODE"

.PP
DVB-T2 PLS code\&. Not used internally\&. It is needed only for file conversion\&. 
.PP
Definition at line 120 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_PLS_MODE"

.PP
DVB-T2 PLS mode\&. Not used internally\&. It is needed only for file conversion\&. 
.PP
Definition at line 121 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_POLARIZATION"

.PP
Satellite polarization (for Satellite delivery systems) 
.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP\&.
.PP
Definition at line 110 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_PRE_BER"

.PP
Bit Error Rate before Viterbi\&. This is the error rate before applying the Forward Error Correction\&. This is a parameter that it is derivated from two counters at the Kernel side\&. 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Definition at line 204 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_QUALITY"

.PP
A quality indicator that represents if a locked channel provides a good, OK or poor signal\&. This is estimated considering the error rates, signal strengh and/or S/N ratio of the carrier\&. 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Definition at line 203 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_SAT_NUMBER"

.PP
Number of the satellite (used on multi-dish Satellite systems) 
.PP
Definition at line 116 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_SERVICE_ID"

.PP
MPEG TS service ID\&. 
.PP
Definition at line 113 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_STAT_COMMAND_START"

.PP
Start number for libdvbv5 statistics commands\&. 
.PP
Definition at line 198 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_STAT_NAME_SIZE"

.PP
Number of statistics commands\&. 
.PP
Definition at line 208 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_STATUS"

.PP
Lock status of a DTV frontend\&. This actually comes from the Kernel, but it uses a separate ioctl\&. 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Definition at line 200 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_USER_COMMAND_START"

.PP
Start number for libdvbv5 user commands\&. 
.PP
Definition at line 108 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_USER_NAME_SIZE"

.PP
Number of user commands\&. 
.PP
Definition at line 126 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_VCHANNEL"

.PP
Digital TV channel number\&. May contain symbols 
.PP
Definition at line 115 of file dvb\-v5\-std\&.h\&.
.SS "#define DTV_VIDEO_PID"

.PP
Video PID\&. 
.PP
Definition at line 111 of file dvb\-v5\-std\&.h\&.
.SS "#define MAX_DELIVERY_SYSTEMS"

.PP
Max number of delivery systems for a given frontend\&. 
.PP
Definition at line 72 of file dvb\-fe\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBdvb_quality\fP"

.PP
Provides an estimation about the user's experience while watching to a given MPEG stream\&. 
.PP
\fBParameters:\fP
.RS 4
\fIDVB_QUAL_UNKNOWN\fP Quality could not be estimated, as the Kernel driver doesn't provide enough statistics
.br
\fIDVB_QUAL_POOR\fP The signal reception is poor\&. Signal loss or packets can be lost too frequently\&. 
.br
\fIDVB_QUAL_OK\fP The signal reception is ok\&. Eventual artifacts could be expected, but it should work\&. 
.br
\fIDVB_QUAL_GOOD\fP The signal is good, and not many errors are happening\&. The user should have a good experience watching the stream\&. 
.RE
.PP

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDVB_QUAL_UNKNOWN \fP\fP
.TP
\fB\fIDVB_QUAL_POOR \fP\fP
.TP
\fB\fIDVB_QUAL_OK \fP\fP
.TP
\fB\fIDVB_QUAL_GOOD \fP\fP
.PP
Definition at line 232 of file dvb\-v5\-std\&.h\&.
.SH "Function Documentation"
.PP 
.SS "int dvb_add_parms_for_sys (struct \fBdvb_v5_fe_parms\fP * parms, fe_delivery_system_t sys)"

.PP
Make dvb properties reflect the current standard\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIsys\fP delivery system to be selected
.RE
.PP
This function prepares the properties cache for a given delivery system\&.
.PP
It is automatically called by \fBdvb_set_sys()\fP, and should not be normally called, except when \fBdvb_fe_dummy()\fP is used\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.SS "const char* const* dvb_attr_names (int cmd)"

.PP
Returns an string array with the valid string values associated with a DVBv5 command\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcmd\fP DVBv5 or libdvbv5 property
.RE
.PP
\fBReturns:\fP
.RS 4
it returns a string array that corresponds to the names associated with the possible values for that property, when available\&. For example: dvb_cmd_name(DTV_CODE_RATE_HP) would return an array with the possible values for the code rates: { '1/2', '2/3', \&.\&.\&. NULL } 
.RE
.PP
\fBNote:\fP
.RS 4
The array always ends with NULL\&. 
.RE
.PP

.SS "const char* dvb_cmd_name (int cmd)"

.PP
Returns the string name associated with a DVBv5 command\&. 
.PP
\fBParameters:\fP
.RS 4
\fIcmd\fP DVBv5 or libdvbv5 property
.RE
.PP
This function gets an integer argument (cmd) and returns a string that corresponds to the name of that property\&.
.PP
\fBReturns:\fP
.RS 4
it returns a string that corresponds to the property name\&. For example: dvb_cmd_name(DTV_GUARD_INTERVAL) would return 'GUARD_INTERVAL' It also returns names for the properties used internally by libdvbv5\&. 
.RE
.PP

.SS "void dvb_fe_close (struct \fBdvb_v5_fe_parms\fP * parms)"

.PP
Closes the frontend and frees allocated resources\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_fe_diseqc_burst (struct \fBdvb_v5_fe_parms\fP * parms, int mini_b)"

.PP
DVB ioctl wrapper for setting SEC DiSeqC tone burst to select between satellite A or B\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fImini_b\fP if different than zero, sends a 22 KHz tone burst to select satellite B\&. Otherwise, sends tone to select satellite A\&.
.RE
.PP
Valid only on certain DISEqC arrangements\&.
.PP
If \fBdvb_v5_fe_parms::lnb\fP is set, this is controlled automatically\&. 
.SS "int dvb_fe_diseqc_cmd (struct \fBdvb_v5_fe_parms\fP * parms, const unsigned len, const unsigned char * buf)"

.PP
DVB ioctl wrapper for setting SEC DiSeqC command\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIlen\fP size of the DiSEqC command 
.br
\fIbuf\fP DiSEqC command to be sent
.RE
.PP
If \fBdvb_v5_fe_parms::lnb\fP is set, this is controlled automatically\&. 
.SS "int dvb_fe_diseqc_reply (struct \fBdvb_v5_fe_parms\fP * parms, unsigned * len, char * buf, int timeout)"

.PP
DVB ioctl wrapper for getting SEC DiSEqC reply\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIlen\fP size of the DiSEqC command 
.br
\fIbuf\fP DiSEqC command to be sent 
.br
\fItimeout\fP maximum time to receive the command, in ms\&.
.RE
.PP
If \fBdvb_v5_fe_parms::lnb\fP is set, this is controlled automatically\&. 
.SS "struct \fBdvb_v5_fe_parms\fP* dvb_fe_dummy (void)"

.PP
Allocates a dummy frontend structure\&. This is useful for some applications that may want to just use the frontend structure internally, without associating it with a real hardware
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to a dummy struct, or NULL if no memory\&. 
.RE
.PP

.SS "int dvb_fe_get_event (struct \fBdvb_v5_fe_parms\fP * parms)"

.PP
Get both status statistics and dvb parameters\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device
.RE
.PP
That's similar of calling both \fBdvb_fe_get_parms()\fP and \fBdvb_fe_get_stats()\fP\&.
.PP
\fBReturns:\fP
.RS 4
It returns 0 if success or an errorno otherwise\&. 
.RE
.PP

.SS "int dvb_fe_get_parms (struct \fBdvb_v5_fe_parms\fP * parms)"

.PP
Prints all the properties at the cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device
.RE
.PP
Gets the properties from the DVB hardware\&. The values will only reflect what's set at the hardware if the frontend is locked\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP\&.
.SS "int dvb_fe_get_stats (struct \fBdvb_v5_fe_parms\fP * parms)"

.PP
Retrieve the stats from the Kernel\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device
.RE
.PP
Updates the stats cache from the available stats at the Kernel\&.
.PP
\fBReturns:\fP
.RS 4
The returned value is 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_fe_is_satellite (uint32_t delivery_system)"

.PP
DVB Ancillary routine to check if a given Delivery system is satellite\&. 
.PP
\fBParameters:\fP
.RS 4
\fIdelivery_system\fP delivery system to be selected 
.RE
.PP

.SS "int dvb_fe_lnb_high_voltage (struct \fBdvb_v5_fe_parms\fP * parms, int on)"

.PP
DVB ioctl wrapper for setting LNBf high voltage\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIon\fP a value different than zero indicates to produce lightly higher voltages instead of 13/18V, in order to compensate for long cables\&. 
.RE
.PP

.SS "struct \fBdvb_v5_fe_parms\fP* dvb_fe_open (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call)"

.PP
Opens a frontend and allocates a structure to work with\&. 
.PP
\fBParameters:\fP
.RS 4
\fIadapter\fP Number of the adapter to open 
.br
\fIfrontend\fP Number of the frontend to open 
.br
\fIverbose\fP Verbosity level of the messages that will be printed 
.br
\fIuse_legacy_call\fP Force to use the DVBv3 calls, instead of using the DVBv5 API
.RE
.PP
This function should be called before using any other function at the frontend library (or the other alternatives: \fBdvb_fe_open2()\fP or \fBdvb_fe_dummy()\fP\&.
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to an allocated data pointer or NULL on error\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.SS "struct \fBdvb_v5_fe_parms\fP* dvb_fe_open2 (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call, \fBdvb_logfunc\fP logfunc)"

.PP
Opens a frontend and allocates a structure to work with\&. 
.PP
\fBParameters:\fP
.RS 4
\fIadapter\fP Number of the adapter to open 
.br
\fIfrontend\fP Number of the frontend to open 
.br
\fIverbose\fP Verbosity level of the messages that will be printed 
.br
\fIuse_legacy_call\fP Force to use the DVBv3 calls, instead of using the DVBv5 API 
.br
\fIlogfunc\fP Callback function to be called when a log event happens\&. Can either store the event into a file or to print it at the TUI/GUI\&.
.RE
.PP
This function should be called before using any other function at the frontend library (or the other alternatives: \fBdvb_fe_open()\fP or \fBdvb_fe_dummy()\fP\&.
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to an allocated data pointer or NULL on error\&. 
.RE
.PP

.SS "struct \fBdvb_v5_fe_parms\fP* dvb_fe_open_flags (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call, \fBdvb_logfunc\fP logfunc, int flags)"

.PP
Opens a frontend and allocates a structure to work with\&. 
.PP
\fBParameters:\fP
.RS 4
\fIadapter\fP Number of the adapter to open 
.br
\fIfrontend\fP Number of the frontend to open 
.br
\fIverbose\fP Verbosity level of the messages that will be printed 
.br
\fIuse_legacy_call\fP Force to use the DVBv3 calls, instead of using the DVBv5 API 
.br
\fIlogfunc\fP Callback function to be called when a log event happens\&. Can either store the event into a file or to print it at the TUI/GUI\&. If NULL, the library will use its internal handler\&. 
.br
\fIflags\fP Flags to be passed to open\&. Currently only two flags are supported: O_RDONLY or O_RDWR\&. Using O_NONBLOCK may hit unexpected issues\&.
.RE
.PP
\fBTodo\fP
.RS 4
Add/check support for O_NONBLOCK at the scan routines\&.
.RE
.PP
.PP
This function should be called before using any other function at the frontend library (or the other alternatives: \fBdvb_fe_open()\fP or \fBdvb_fe_dummy()\fP\&.
.PP
In general, this is called using O_RDWR, except if all that it is wanted is to check the DVB frontend statistics\&.
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to an allocated data pointer or NULL on error\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP\&.
.SS "void dvb_fe_prt_parms (const struct \fBdvb_v5_fe_parms\fP * parms)"

.PP
Prints all the properties at the cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device
.RE
.PP
Used mostly for debugging issues\&. 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP\&.
.SS "float dvb_fe_retrieve_ber (struct \fBdvb_v5_fe_parms\fP * parms, unsigned layer, enum fecap_scale_params * scale)"

.PP
Retrieve the BER stats from cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIlayer\fP DTV layer 
.br
\fIscale\fP retrieves the scale
.RE
.PP
Gets the value for BER stats from stats cache, on a given layer\&. Layer 0 is always present\&. On DTV standards that doesn't have layers, it returns the same value as \fBdvb_fe_retrieve_stats()\fP for layer = 0\&.
.PP
For DTV standards with multiple layers, like ISDB, layer=1 is layer 'A', layer=2 is layer 'B' and layer=3 is layer 'C'\&. Please notice that not all frontends support per-layer stats\&. Also, the layer value is only valid if the layer exists at the original stream\&. Also, on such standards, layer 0 is typically a mean value of the layers, or a sum of events (if FE_SCALE_COUNTER)\&.
.PP
For it to be valid, \fBdvb_fe_get_stats()\fP should be called first\&.
.PP
\fBReturns:\fP
.RS 4
It returns a float number for the BER value\&. If the statistics is not available for any reason, scale will be equal to FE_SCALE_NOT_AVAILABLE\&. 
.RE
.PP

.SS "int dvb_fe_retrieve_parm (const struct \fBdvb_v5_fe_parms\fP * parms, unsigned cmd, uint32_t * value)"

.PP
Retrieves the value of a DVBv5/libdvbv5 property\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIcmd\fP DVBv5 or libdvbv5 property 
.br
\fIvalue\fP Pointer to an uint32_t where the value will be stored\&.
.RE
.PP
This reads the value of a property stored at the cache\&. Before using it, a \fBdvb_fe_get_parms()\fP is likely required\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-zap\&.c\fP\&.
.SS "float dvb_fe_retrieve_per (struct \fBdvb_v5_fe_parms\fP * parms, unsigned layer)"

.PP
Retrieve the PER stats from cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIlayer\fP DTV layer
.RE
.PP
Gets the value for BER stats from stats cache, on a given layer\&. Layer 0 is always present\&. On DTV standards that doesn't have layers, it returns the same value as \fBdvb_fe_retrieve_stats()\fP for layer = 0\&.
.PP
For DTV standards with multiple layers, like ISDB, layer=1 is layer 'A', layer=2 is layer 'B' and layer=3 is layer 'C'\&. Please notice that not all frontends support per-layer stats\&. Also, the layer value is only valid if the layer exists at the original stream\&. Also, on such standards, layer 0 is typically a mean value of the layers, or a sum of events (if FE_SCALE_COUNTER)\&.
.PP
For it to be valid, \fBdvb_fe_get_stats()\fP should be called first\&.
.PP
\fBReturns:\fP
.RS 4
A negative value indicates error\&. 
.RE
.PP

.SS "enum \fBdvb_quality\fP dvb_fe_retrieve_quality (struct \fBdvb_v5_fe_parms\fP * parms, unsigned layer)"

.PP
Retrieve the quality stats from cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIlayer\fP DTV layer
.RE
.PP
Gets a quality measure for a given layer\&. Layer 0 is always present\&. On DTV standards that doesn't have layers, it returns the same value as \fBdvb_fe_retrieve_stats()\fP for layer = 0\&.
.PP
For DTV standards with multiple layers, like ISDB, layer=1 is layer 'A', layer=2 is layer 'B' and layer=3 is layer 'C'\&. Please notice that not all frontends support per-layer stats\&. Also, the layer value is only valid if the layer exists at the original stream\&. Also, on such standards, layer 0 is typically a mean value of the layers, or a sum of events (if FE_SCALE_COUNTER)\&.
.PP
For it to be valid, \fBdvb_fe_get_stats()\fP should be called first\&.
.PP
\fBReturns:\fP
.RS 4
returns an enum dvb_quantity, where DVB_QUAL_UNKNOWN means that the stat isnot available\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP\&.
.SS "int dvb_fe_retrieve_stats (struct \fBdvb_v5_fe_parms\fP * parms, unsigned cmd, uint32_t * value)"

.PP
Retrieve the stats for a DTV layer from cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIcmd\fP DVBv5 or libdvbv5 property 
.br
\fIvalue\fP DTV value pointer
.RE
.PP
Gets the value for one stats property for layer = 0\&.
.PP
For it to be valid, \fBdvb_fe_get_stats()\fP should be called first\&.
.PP
\fBReturns:\fP
.RS 4
The returned value is 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.SS "struct dtv_stats* dvb_fe_retrieve_stats_layer (struct \fBdvb_v5_fe_parms\fP * parms, unsigned cmd, unsigned layer)"

.PP
Retrieve the stats for a DTV layer from cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIcmd\fP DVBv5 or libdvbv5 property 
.br
\fIlayer\fP DTV layer
.RE
.PP
Gets the value for one stats cache, on a given layer\&. Layer 0 is always present\&. On DTV standards that doesn't have layers, it returns the same value as \fBdvb_fe_retrieve_stats()\fP for layer = 0\&.
.PP
For DTV standards with multiple layers, like ISDB, layer=1 is layer 'A', layer=2 is layer 'B' and layer=3 is layer 'C'\&. Please notice that not all frontends support per-layer stats\&. Also, the layer value is only valid if the layer exists at the original stream\&. Also, on such standards, layer 0 is typically a mean value of the layers, or a sum of events (if FE_SCALE_COUNTER)\&.
.PP
For it to be valid, \fBdvb_fe_get_stats()\fP should be called first\&.
.PP
\fBReturns:\fP
.RS 4
It returns a struct dtv_stats if succeed or NULL otherwise\&. 
.RE
.PP

.SS "int dvb_fe_sec_tone (struct \fBdvb_v5_fe_parms\fP * parms, fe_sec_tone_mode_t tone)"

.PP
DVB ioctl wrapper for setting SEC tone\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fItone\fP tone setting, as defined by DVB fe_sec_tone_mode_t type
.RE
.PP
If \fBdvb_v5_fe_parms::lnb\fP is set, this is controlled automatically\&. 
.SS "int dvb_fe_sec_voltage (struct \fBdvb_v5_fe_parms\fP * parms, int on, int v18)"

.PP
DVB ioctl wrapper for setting SEC voltage\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIon\fP a value different than zero indicates to enable voltage on a Satellite Equipment Control (SEC) 
.br
\fIv18\fP if on != 0, a value different than zero means 18 Volts; zero means 13 Volts\&.
.RE
.PP
If \fBdvb_v5_fe_parms::lnb\fP is set, this is controlled automatically\&. 
.SS "int dvb_fe_set_default_country (struct \fBdvb_v5_fe_parms\fP * parms, const char * country)"

.PP
Set default country variant of delivery systems like ISDB-T\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIcountry\fP default country, in ISO 3166-1 two letter code\&. If NULL, default charset is guessed from locale environment variables\&.
.RE
.PP
\fBReturns:\fP
.RS 4
0 if success or an errorno otherwise\&.
.RE
.PP
'COUNTRY' property in dvb_fe_set_parm() overrides the setting\&. 
.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_fe_set_parms (struct \fBdvb_v5_fe_parms\fP * parms)"

.PP
Prints all the properties at the cache\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device
.RE
.PP
Writes the properties stored at the DVB cache at the DVB hardware\&. At return, some properties could have a different value, as the frontend may not support the values set\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_fe_snprintf_eng (char * buf, int len, float val)"

.PP
Ancillary function to sprintf on ENG format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIbuf\fP buffer to store the value 
.br
\fIlen\fP buffer length 
.br
\fIval\fP value to be printed
.RE
.PP
On ENG notation, the exponential value should be multiple of 3\&. This is good to display some values, like BER\&.
.PP
\fBReturns:\fP
.RS 4
At return, it shows the actual size of the print\&. A negative value indicates an error\&. 
.RE
.PP

.SS "int dvb_fe_snprintf_stat (struct \fBdvb_v5_fe_parms\fP * parms, uint32_t cmd, char * display_name, int layer, char ** buf, int * len, int * show_layer_name)"

.PP
Ancillary function to sprintf on ENG format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIcmd\fP DVBv5 or libdvbv5 property 
.br
\fIdisplay_name\fP String with the name of the property to be shown 
.br
\fIlayer\fP DTV Layer 
.br
\fIbuf\fP buffer to store the value 
.br
\fIlen\fP buffer length 
.br
\fIshow_layer_name\fP a value different than zero shows the layer name, if the layer is bigger than zero\&.
.RE
.PP
This function calls internally \fBdvb_fe_retrieve_stats_layer()\fP\&. It allows to print a DVBv5 statistics value into a string\&. An extra property is available (DTV_QUALITY) with prints either one of the values: Poor, Ok or Good, depending on the overall measures\&.
.PP
\fBReturns:\fP
.RS 4
: It returns the length of the printed data\&. A negative value indicates an error\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_fe_store_parm (struct \fBdvb_v5_fe_parms\fP * parms, unsigned cmd, uint32_t value)"

.PP
Stores the value of a DVBv5/libdvbv5 property\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIcmd\fP DVBv5 or libdvbv5 property 
.br
\fIvalue\fP Pointer to an uint32_t where the value will be stored\&.
.RE
.PP
This stores the value of a property at the cache\&. The value will only be send to the hardware after calling \fBdvb_fe_set_parms()\fP\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_set_compat_delivery_system (struct \fBdvb_v5_fe_parms\fP * parms, uint32_t desired_system)"

.PP
Sets the delivery system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIdesired_system\fP delivery system to be selected
.RE
.PP
This function changes the delivery system of the frontend\&. By default, the libdvbv5 will use the first available delivery system\&. If another delivery system is desirable, this function should be called before being able to store the properties for the new delivery system via \fBdvb_fe_store_parm()\fP\&.
.PP
This function is an enhanced version of \fBdvb_set_sys()\fP\&. It has an special logic inside to work with Kernels that supports only DVBv3\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-zap\&.c\fP\&.
.SS "int dvb_set_sys (struct \fBdvb_v5_fe_parms\fP * parms, fe_delivery_system_t sys)"

.PP
Sets the delivery system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP struct \fBdvb_v5_fe_parms\fP pointer to the opened device 
.br
\fIsys\fP delivery system to be selected
.RE
.PP
This function changes the delivery system of the frontend\&. By default, the libdvbv5 will use the first available delivery system\&. If another delivery system is desirable, this function should be called before being able to store the properties for the new delivery system via \fBdvb_fe_store_parm()\fP\&.
.PP
\fBReturns:\fP
.RS 4
Return 0 if success, EINVAL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libdvbv5 from the source code\&.
