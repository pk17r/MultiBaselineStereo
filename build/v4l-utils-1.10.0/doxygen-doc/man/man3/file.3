.TH "file" 3 "Sun Jan 24 2016" "Version 1.10.0" "libdvbv5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
file \- Channel and transponder file read/write
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBdvb\-file\&.h\fP"
.br
.RI "\fIProvides interfaces to deal with DVB channel and program files\&. \fP"
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBdvb_elementary_pid\fP"
.br
.RI "\fIassociates an elementary stream type with its PID \fP"
.ti -1c
.RI "struct \fBdvb_entry\fP"
.br
.RI "\fIRepresents one entry on a DTV file\&. \fP"
.ti -1c
.RI "struct \fBdvb_parse_table\fP"
.br
.RI "\fIDescribes the fields to parse on a file\&. \fP"
.ti -1c
.RI "struct \fBdvb_parse_struct\fP"
.br
.RI "\fIDescribes the format to parse an specific delivery system\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBdvb_file_formats\fP { \fBFILE_UNKNOWN\fP, \fBFILE_ZAP\fP, \fBFILE_CHANNEL\fP, \fBFILE_DVBV5\fP, \fBFILE_VDR\fP }
.RI "\fIKnown file formats\&. \fP""
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBdvb_file_free\fP (struct \fBdvb_file\fP *\fBdvb_file\fP)"
.br
.RI "\fIDeallocates memory associated with a struct \fBdvb_file\fP\&. \fP"
.ti -1c
.RI "struct \fBdvb_file\fP * \fBdvb_read_file\fP (const char *fname)"
.br
.RI "\fIRead a file at libdvbv5 format\&. \fP"
.ti -1c
.RI "int \fBdvb_write_file\fP (const char *fname, struct \fBdvb_file\fP *\fBdvb_file\fP)"
.br
.RI "\fIWrite a file at libdvbv5 format\&. \fP"
.ti -1c
.RI "struct \fBdvb_file\fP * \fBdvb_read_file_format\fP (const char *fname, uint32_t delsys, enum \fBdvb_file_formats\fP format)"
.br
.RI "\fIRead a file on any format natively supported by the library\&. \fP"
.ti -1c
.RI "int \fBdvb_write_file_format\fP (const char *fname, struct \fBdvb_file\fP *\fBdvb_file\fP, uint32_t delsys, enum \fBdvb_file_formats\fP format)"
.br
.RI "\fIWrite a file on any format natively supported by the library\&. \fP"
.ti -1c
.RI "int \fBdvb_store_entry_prop\fP (struct \fBdvb_entry\fP *entry, uint32_t cmd, uint32_t value)"
.br
.RI "\fIStores a key/value pair on a DVB file entry\&. \fP"
.ti -1c
.RI "int \fBdvb_retrieve_entry_prop\fP (struct \fBdvb_entry\fP *entry, uint32_t cmd, uint32_t *value)"
.br
.RI "\fIRetrieves the value associated witha key on a DVB file entry\&. \fP"
.ti -1c
.RI "int \fBdvb_store_channel\fP (struct \fBdvb_file\fP **\fBdvb_file\fP, struct \fBdvb_v5_fe_parms\fP *parms, struct \fBdvb_v5_descriptors\fP *\fBdvb_desc\fP, int get_detected, int get_nit)"
.br
.RI "\fIstored a new scanned channel into a \fBdvb_file\fP struct \fP"
.ti -1c
.RI "int \fBdvb_parse_delsys\fP (const char *name)"
.br
.RI "\fIAncillary function that seeks for a delivery system\&. \fP"
.ti -1c
.RI "enum \fBdvb_file_formats\fP \fBdvb_parse_format\fP (const char *name)"
.br
.RI "\fIAncillary function that parses the name of a file format\&. \fP"
.ti -1c
.RI "struct \fBdvb_file\fP * \fBdvb_parse_format_oneline\fP (const char *fname, uint32_t delsys, const struct \fBdvb_parse_file\fP *parse_file)"
.br
.RI "\fIRead and parses a one line file format\&. \fP"
.ti -1c
.RI "int \fBdvb_write_format_oneline\fP (const char *fname, struct \fBdvb_file\fP *\fBdvb_file\fP, uint32_t delsys, const struct \fBdvb_parse_file\fP *parse_file)"
.br
.RI "\fIWrites a file into an one line file format\&. \fP"
.ti -1c
.RI "int \fBdvb_write_format_vdr\fP (const char *fname, struct \fBdvb_file\fP *\fBdvb_file\fP)"
.br
.RI "\fIWrites a file into vdr format (compatible up to version 2\&.1) \fP"
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "const struct \fBdvb_parse_file\fP \fBchannel_file_format\fP"
.br
.RI "\fIFile format definitions for dvb-apps channel format\&. \fP"
.ti -1c
.RI "const struct \fBdvb_parse_file\fP \fBchannel_file_zap_format\fP"
.br
.RI "\fIFile format definitions for dvb-apps zap format\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBdvb_file_formats\fP"

.PP
Known file formats\&. Please notice that the channel format defined here has a few optional fields that aren't part of the dvb-apps format, for DVB-S2 and for DVB-T2\&. They're there to match the formats found at dtv-scan-tables package up to September, 5 2014\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFILE_UNKNOWN \fP\fP
File format is unknown\&. 
.TP
\fB\fIFILE_ZAP \fP\fP
File is at the dvb-apps 'dvbzap' format\&. 
.TP
\fB\fIFILE_CHANNEL \fP\fP
File is at the dvb-apps output format for dvb-zap\&. 
.TP
\fB\fIFILE_DVBV5 \fP\fP
File is at libdvbv5 format\&. 
.TP
\fB\fIFILE_VDR \fP\fP
File is at DVR format (as supported on version 2\&.1\&.6)\&. Note: this is only supported as an output format\&. 
.PP
Definition at line 226 of file dvb\-file\&.h\&.
.SH "Function Documentation"
.PP 
.SS "static void dvb_file_free (struct \fBdvb_file\fP * dvb_file)\fC [inline]\fP, \fC [static]\fP"

.PP
Deallocates memory associated with a struct \fBdvb_file\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fI\fBdvb_file\fP\fP \fBdvb_file\fP struct to be deallocated
.RE
.PP
This function assumes that several functions were dynamically allocated by the library file functions\&. 
.PP
\fBExamples: \fP
.in +1c
\fBdvb\-format\-convert\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Definition at line 249 of file dvb\-file\&.h\&.
.PP
References dvb_entry::audio_pid, dvb_entry::channel, dvb_parse_delsys(), dvb_parse_format(), dvb_parse_format_oneline(), dvb_read_file(), dvb_read_file_format(), dvb_retrieve_entry_prop(), dvb_store_channel(), dvb_store_entry_prop(), dvb_write_file(), dvb_write_file_format(), dvb_write_format_oneline(), dvb_write_format_vdr(), dvb_file::first_entry, dvb_file::fname, dvb_entry::lnb, dvb_entry::location, dvb_entry::next, dvb_entry::other_el_pid, dvb_entry::vchannel, and dvb_entry::video_pid\&.
.SS "int dvb_parse_delsys (const char * name)"

.PP
Ancillary function that seeks for a delivery system\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP string containing the name of the Delivery System to seek
.RE
.PP
If the name is found, this function returns the DVBv5 property that corresponds to the string given\&. The function is case-insensitive, and it can check for alternate ways to write the name of a Delivery System\&. Currently, it supports: DVB-C, DVB-H, DVB-S, DVB-S2, DVB-T, DVB-T2, ISDB-C, ISDB-S, ISDB-T, ATSC-MH, DVBC/ANNEX_A, DVBC/ANNEX_B, DVBT, DSS, DVBS, DVBS2, DVBH, ISDBT, ISDBS, ISDBC, ATSC, ATSCMH, DTMB, CMMB, DAB, DVBT2, TURBO, DVBC/ANNEX_C\&. Please notice that this doesn't mean that all those standards are properly supported by the library\&.
.PP
\fBReturns:\fP
.RS 4
Returns the Delivery System property number if success, -1 if error\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-fe\-tool\&.c\fP, and \fBdvb\-format\-convert\&.c\fP\&.
.PP
Referenced by dvb_file_free()\&.
.SS "enum \fBdvb_file_formats\fP dvb_parse_format (const char * name)"

.PP
Ancillary function that parses the name of a file format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIname\fP string containing the name of the format Current valid names are: ZAP, CHANNEL, VDR and DVBV5\&. The name is case-insensitive\&.
.RE
.PP
\fBReturns:\fP
.RS 4
It returns FILE_ZAP, FILE_CHANNEL, FILE_VDR or FILE_DVBV5 if the name was translated\&. FILE_UNKNOWN otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-format\-convert\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Referenced by dvb_file_free()\&.
.SS "struct \fBdvb_file\fP* dvb_parse_format_oneline (const char * fname, uint32_t delsys, const struct \fBdvb_parse_file\fP * parse_file)"

.PP
Read and parses a one line file format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name 
.br
\fIdelsys\fP delivery system 
.br
\fIparse_file\fP pointer struct \fBdvb_parse_file\fP
.RE
.PP
\fBReturns:\fP
.RS 4
It a pointer to struct \fBdvb_file\fP on success, NULL otherwise\&.
.RE
.PP
This function is called internally by dvb_read_file_format\&. 
.PP
Referenced by dvb_file_free()\&.
.SS "struct \fBdvb_file\fP* dvb_read_file (const char * fname)"

.PP
Read a file at libdvbv5 format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name
.RE
.PP
\fBReturns:\fP
.RS 4
It returns a pointer to struct \fBdvb_file\fP describing the entries that were read from the file\&. If it fails, NULL is returned\&. 
.RE
.PP

.PP
Referenced by dvb_file_free()\&.
.SS "struct \fBdvb_file\fP* dvb_read_file_format (const char * fname, uint32_t delsys, enum \fBdvb_file_formats\fP format)"

.PP
Read a file on any format natively supported by the library\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name 
.br
\fIdelsys\fP Delivery system, as specified by enum fe_delivery_system 
.br
\fIformat\fP Name of the format to be read
.RE
.PP
\fBReturns:\fP
.RS 4
It returns a pointer to struct \fBdvb_file\fP describing the entries that were read from the file\&. If it fails, NULL is returned\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-format\-convert\&.c\fP, \fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_retrieve_entry_prop (struct \fBdvb_entry\fP * entry, uint32_t cmd, uint32_t * value)"

.PP
Retrieves the value associated witha key on a DVB file entry\&. 
.PP
\fBParameters:\fP
.RS 4
\fIentry\fP entry to be used 
.br
\fIcmd\fP key for the property to be found\&. It be one of the DVBv5 properties, plus the libdvbv5 ones, as defined at \fBdvb-v5-std\&.h\fP 
.br
\fIvalue\fP pointer to store the value associated with the property\&.
.RE
.PP
This function seeks for a property with the name specified by cmd and fills value with its contents\&.
.PP
\fBReturns:\fP
.RS 4
Returns 0 if success, or, -1 if the entry doesn't exist\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP, and \fBdvbv5\-zap\&.c\fP\&.
.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_store_channel (struct \fBdvb_file\fP ** dvb_file, struct \fBdvb_v5_fe_parms\fP * parms, struct \fBdvb_v5_descriptors\fP * dvb_desc, int get_detected, int get_nit)"

.PP
stored a new scanned channel into a \fBdvb_file\fP struct 
.PP
\fBParameters:\fP
.RS 4
\fI\fBdvb_file\fP\fP file struct to be filled 
.br
\fIparms\fP struct \fBdvb_v5_fe_parms\fP used by libdvbv5 frontend 
.br
\fI\fBdvb_desc\fP\fP struct \fBdvb_desc\fP as described at \fBdescriptors\&.h\fP, filled with the descriptors associated with a DVB channel\&. those descriptors can be filled by calling one of the scan functions defined at \fBdvb-sat\&.h\fP\&. 
.br
\fIget_detected\fP if different than zero, uses the frontend parameters obtained from the device driver (such as modulation, FEC, etc) 
.br
\fIget_nit\fP if true, uses the parameters obtained from the MPEG-TS NIT table to add newly detected transponders\&.
.RE
.PP
This function should be used to store the services found on a scanned transponder\&. Initially, it copies the same parameters used to set the frontend, that came from a file where the Service ID and Elementary Stream PIDs are unknown\&. At tuning time, it is common to set the device to tune on auto-detection mode (e\&. g\&. using QAM/AUTO, for example, to autodetect the QAM modulation)\&. The libdvbv5's logic will be to check the detected values\&. So, the modulation might, for example, have changed to QAM/256\&. In such case, if get_detected is 0, it will store QAM/AUTO at the struct\&. If get_detected is different than zero, it will store QAM/256\&. If get_nit is different than zero, and if the MPEG-TS has info about other physical channels/transponders, this function will add newer entries to \fBdvb_file\fP, for it to seek for new transponders\&. This is very useful especially for DVB-C, where all transponders belong to the same operator\&. Knowing one frequency is generally enough to get all DVB-C transponders\&.
.PP
\fBReturns:\fP
.RS 4
Returns 0 if success, or, -1 if error\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP\&.
.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_store_entry_prop (struct \fBdvb_entry\fP * entry, uint32_t cmd, uint32_t value)"

.PP
Stores a key/value pair on a DVB file entry\&. 
.PP
\fBParameters:\fP
.RS 4
\fIentry\fP entry to be filled 
.br
\fIcmd\fP key for the property to be used\&. It be one of the DVBv5 properties, plus the libdvbv5 ones, as defined at \fBdvb-v5-std\&.h\fP 
.br
\fIvalue\fP value for the property\&.
.RE
.PP
This function seeks for a property with the name specified by cmd and fills it with value\&. If the entry doesn't exist, it creates a new key\&.
.PP
\fBReturns:\fP
.RS 4
Returns 0 if success, or, if the entry has already DTV_MAX_COMMAND properties, it returns -1\&. 
.RE
.PP

.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_write_file (const char * fname, struct \fBdvb_file\fP * dvb_file)"

.PP
Write a file at libdvbv5 format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name 
.br
\fI\fBdvb_file\fP\fP contents of the file to be written
.RE
.PP
\fBReturns:\fP
.RS 4
It returns zero if success, or a positive error number if it fails\&. 
.RE
.PP

.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_write_file_format (const char * fname, struct \fBdvb_file\fP * dvb_file, uint32_t delsys, enum \fBdvb_file_formats\fP format)"

.PP
Write a file on any format natively supported by the library\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name 
.br
\fI\fBdvb_file\fP\fP contents of the file to be written 
.br
\fIdelsys\fP Delivery system, as specified by enum fe_delivery_system 
.br
\fIformat\fP Name of the format to be read
.RE
.PP
\fBReturns:\fP
.RS 4
It a pointer to struct \fBdvb_file\fP on success, NULL otherwise\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvb\-format\-convert\&.c\fP, and \fBdvbv5\-scan\&.c\fP\&.
.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_write_format_oneline (const char * fname, struct \fBdvb_file\fP * dvb_file, uint32_t delsys, const struct \fBdvb_parse_file\fP * parse_file)"

.PP
Writes a file into an one line file format\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name 
.br
\fI\fBdvb_file\fP\fP contents of the file to be written 
.br
\fIdelsys\fP delivery system 
.br
\fIparse_file\fP pointer struct \fBdvb_parse_file\fP
.RE
.PP
\fBReturns:\fP
.RS 4
It returns zero if success, or a positive error number if it fails\&.
.RE
.PP
This function is called internally by dvb_write_file_format\&. 
.PP
Referenced by dvb_file_free()\&.
.SS "int dvb_write_format_vdr (const char * fname, struct \fBdvb_file\fP * dvb_file)"

.PP
Writes a file into vdr format (compatible up to version 2\&.1) 
.PP
\fBParameters:\fP
.RS 4
\fIfname\fP file name 
.br
\fI\fBdvb_file\fP\fP contents of the file to be written
.RE
.PP
\fBReturns:\fP
.RS 4
It returns zero if success, or a positive error number if it fails\&.
.RE
.PP
This function is called internally by dvb_write_file_format\&. 
.PP
Referenced by dvb_file_free()\&.
.SH "Variable Documentation"
.PP 
.SS "const struct \fBdvb_parse_file\fP channel_file_format"

.PP
File format definitions for dvb-apps channel format\&. 
.SS "const struct \fBdvb_parse_file\fP channel_file_zap_format"

.PP
File format definitions for dvb-apps zap format\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for libdvbv5 from the source code\&.
