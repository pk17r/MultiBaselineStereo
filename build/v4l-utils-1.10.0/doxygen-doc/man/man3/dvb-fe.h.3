.TH "lib/include/libdvbv5/dvb-fe.h" 3 "Sun Jan 24 2016" "Version 1.10.0" "libdvbv5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
lib/include/libdvbv5/dvb-fe.h \- Provides interfaces to deal with DVB frontend\&.  

.SH SYNOPSIS
.br
.PP
\fC#include <stdio\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br
\fC#include <sys/stat\&.h>\fP
.br
\fC#include <fcntl\&.h>\fP
.br
\fC#include <sys/ioctl\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include 'dvb\-frontend\&.h'\fP
.br
\fC#include 'dvb\-sat\&.h'\fP
.br
\fC#include 'dvb\-log\&.h'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP"
.br
.RI "\fIKeeps data needed to handle the DVB frontend\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBARRAY_SIZE\fP(x)"
.br
.RI "\fICalculates the number of elements of an array\&. \fP"
.ti -1c
.RI "#define \fBMAX_DELIVERY_SYSTEMS\fP"
.br
.RI "\fIMax number of delivery systems for a given frontend\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_dummy\fP (void)"
.br
.RI "\fIAllocates a dummy frontend structure\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_open_flags\fP (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call, \fBdvb_logfunc\fP logfunc, int flags)"
.br
.RI "\fIOpens a frontend and allocates a structure to work with\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_open\fP (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call)"
.br
.RI "\fIOpens a frontend and allocates a structure to work with\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_fe_parms\fP * \fBdvb_fe_open2\fP (int adapter, int frontend, unsigned verbose, unsigned use_legacy_call, \fBdvb_logfunc\fP logfunc)"
.br
.RI "\fIOpens a frontend and allocates a structure to work with\&. \fP"
.ti -1c
.RI "void \fBdvb_fe_close\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fICloses the frontend and frees allocated resources\&. \fP"
.ti -1c
.RI "const char * \fBdvb_cmd_name\fP (int cmd)"
.br
.RI "\fIReturns the string name associated with a DVBv5 command\&. \fP"
.ti -1c
.RI "const char *const * \fBdvb_attr_names\fP (int cmd)"
.br
.RI "\fIReturns an string array with the valid string values associated with a DVBv5 command\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_retrieve_parm\fP (const struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, uint32_t *value)"
.br
.RI "\fIRetrieves the value of a DVBv5/libdvbv5 property\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_store_parm\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, uint32_t value)"
.br
.RI "\fIStores the value of a DVBv5/libdvbv5 property\&. \fP"
.ti -1c
.RI "int \fBdvb_set_sys\fP (struct \fBdvb_v5_fe_parms\fP *parms, fe_delivery_system_t sys)"
.br
.RI "\fISets the delivery system\&. \fP"
.ti -1c
.RI "int \fBdvb_add_parms_for_sys\fP (struct \fBdvb_v5_fe_parms\fP *parms, fe_delivery_system_t sys)"
.br
.RI "\fIMake dvb properties reflect the current standard\&. \fP"
.ti -1c
.RI "int \fBdvb_set_compat_delivery_system\fP (struct \fBdvb_v5_fe_parms\fP *parms, uint32_t desired_system)"
.br
.RI "\fISets the delivery system\&. \fP"
.ti -1c
.RI "void \fBdvb_fe_prt_parms\fP (const struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIPrints all the properties at the cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_set_parms\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIPrints all the properties at the cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_get_parms\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIPrints all the properties at the cache\&. \fP"
.ti -1c
.RI "struct dtv_stats * \fBdvb_fe_retrieve_stats_layer\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, unsigned layer)"
.br
.RI "\fIRetrieve the stats for a DTV layer from cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_retrieve_stats\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned cmd, uint32_t *value)"
.br
.RI "\fIRetrieve the stats for a DTV layer from cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_get_stats\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIRetrieve the stats from the Kernel\&. \fP"
.ti -1c
.RI "float \fBdvb_fe_retrieve_ber\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned layer, enum fecap_scale_params *scale)"
.br
.RI "\fIRetrieve the BER stats from cache\&. \fP"
.ti -1c
.RI "float \fBdvb_fe_retrieve_per\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned layer)"
.br
.RI "\fIRetrieve the PER stats from cache\&. \fP"
.ti -1c
.RI "enum \fBdvb_quality\fP \fBdvb_fe_retrieve_quality\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned layer)"
.br
.RI "\fIRetrieve the quality stats from cache\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_snprintf_eng\fP (char *buf, int len, float val)"
.br
.RI "\fIAncillary function to sprintf on ENG format\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_snprintf_stat\fP (struct \fBdvb_v5_fe_parms\fP *parms, uint32_t cmd, char *display_name, int layer, char **buf, int *len, int *show_layer_name)"
.br
.RI "\fIAncillary function to sprintf on ENG format\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_get_event\fP (struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fIGet both status statistics and dvb parameters\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_sec_voltage\fP (struct \fBdvb_v5_fe_parms\fP *parms, int on, int v18)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC voltage\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_sec_tone\fP (struct \fBdvb_v5_fe_parms\fP *parms, fe_sec_tone_mode_t tone)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC tone\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_lnb_high_voltage\fP (struct \fBdvb_v5_fe_parms\fP *parms, int on)"
.br
.RI "\fIDVB ioctl wrapper for setting LNBf high voltage\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_diseqc_burst\fP (struct \fBdvb_v5_fe_parms\fP *parms, int mini_b)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC DiSeqC tone burst to select between satellite A or B\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_diseqc_cmd\fP (struct \fBdvb_v5_fe_parms\fP *parms, const unsigned len, const unsigned char *buf)"
.br
.RI "\fIDVB ioctl wrapper for setting SEC DiSeqC command\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_diseqc_reply\fP (struct \fBdvb_v5_fe_parms\fP *parms, unsigned *len, char *buf, int timeout)"
.br
.RI "\fIDVB ioctl wrapper for getting SEC DiSEqC reply\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_is_satellite\fP (uint32_t delivery_system)"
.br
.RI "\fIDVB Ancillary routine to check if a given Delivery system is satellite\&. \fP"
.ti -1c
.RI "int \fBdvb_fe_set_default_country\fP (struct \fBdvb_v5_fe_parms\fP *parms, const char *country)"
.br
.RI "\fISet default country variant of delivery systems like ISDB-T\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
Provides interfaces to deal with DVB frontend\&. 


.PP
\fBCopyright:\fP
.RS 4
GNU General Public License version 2 (GPLv2) 
.RE
.PP
\fBAuthor:\fP
.RS 4
Mauro Carvalho Chehab
.RE
.PP
The libdvbv5 API works with a set of key/value properties\&. There are two types of properties:
.PP
.IP "\(bu" 2
The ones defined at the Kernel's frontent API, that are found at /usr/include/linux/dvb/frontend\&.h (actually, it uses a local copy of that file, stored at \&./include/linux/dvb/frontend\&.h)
.IP "\(bu" 2
Some extra properties used by libdvbv5\&. Those can be found at \fBlib/include/libdvbv5/dvb-v5-std\&.h\fP and start at DTV_USER_COMMAND_START\&.
.PP
.PP
Just like the DTV properties, the stats are cached\&. That warrants that all stats are got at the same time, when \fBdvb_fe_get_stats()\fP is called\&.
.PP
\fBBug Report\fP
.RS 4
Please submit bug reports and patches to linux-media@vger.kernel.org 
.RE
.PP

.PP
Definition in file \fBdvb\-fe\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libdvbv5 from the source code\&.
