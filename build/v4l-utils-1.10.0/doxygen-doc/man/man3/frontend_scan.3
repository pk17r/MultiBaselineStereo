.TH "frontend_scan" 3 "Sun Jan 24 2016" "Version 1.10.0" "libdvbv5" \" -*- nroff -*-
.ad l
.nh
.SH NAME
frontend_scan \- Digital TV frontend scan
.SS "Files"

.in +1c
.ti -1c
.RI "file \fBdvb\-scan\&.h\fP"
.br
.RI "\fIProvides interfaces to scan programs inside MPEG-TS digital TV streams\&. \fP"
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBdvb_v5_descriptors_program\fP"
.br
.RI "\fIAssociates PMT with PAT tables\&. \fP"
.ti -1c
.RI "struct \fBdvb_v5_descriptors\fP"
.br
.RI "\fIContains the descriptors needed to scan the Service ID and other relevant info at a MPEG-TS Digital TV stream\&. \fP"
.ti -1c
.RI "struct \fBdvb_table_filter\fP"
.br
.RI "\fIDescribes the PES filters used by DVB scan\&. \fP"
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int( \fBcheck_frontend_t\fP) (void *args, struct \fBdvb_v5_fe_parms\fP *parms)"
.br
.RI "\fICallback for the application to show the frontend status\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBdvb_table_filter_free\fP (struct \fBdvb_table_filter\fP *sect)"
.br
.RI "\fIdeallocates all data associated with a table filter \fP"
.ti -1c
.RI "int \fBdvb_read_section\fP (struct \fBdvb_v5_fe_parms\fP *parms, int dmx_fd, unsigned char tid, uint16_t pid, void **table, unsigned timeout)"
.br
.RI "\fIread MPEG-TS tables that comes from a DTV card \fP"
.ti -1c
.RI "int \fBdvb_read_section_with_id\fP (struct \fBdvb_v5_fe_parms\fP *parms, int dmx_fd, unsigned char tid, uint16_t pid, int ts_id, void **table, unsigned timeout)"
.br
.RI "\fIread MPEG-TS tables that comes from a DTV card with an specific table section ID \fP"
.ti -1c
.RI "int \fBdvb_read_sections\fP (struct \fBdvb_v5_fe_parms\fP *parms, int dmx_fd, struct \fBdvb_table_filter\fP *sect, unsigned timeout)"
.br
.RI "\fIread MPEG-TS tables that comes from a DTV card \fP"
.ti -1c
.RI "struct \fBdvb_v5_descriptors\fP * \fBdvb_scan_alloc_handler_table\fP (uint32_t delivery_system)"
.br
.RI "\fIallocates a struct \fBdvb_v5_descriptors\fP \fP"
.ti -1c
.RI "void \fBdvb_scan_free_handler_table\fP (struct \fBdvb_v5_descriptors\fP *dvb_scan_handler)"
.br
.RI "\fIfrees a struct \fBdvb_v5_descriptors\fP \fP"
.ti -1c
.RI "struct \fBdvb_v5_descriptors\fP * \fBdvb_get_ts_tables\fP (struct \fBdvb_v5_fe_parms\fP *parms, int dmx_fd, uint32_t delivery_system, unsigned other_nit, unsigned timeout_multiply)"
.br
.RI "\fIScans a DVB stream, looking for the tables needed to identify the programs inside a MPEG-TS\&. \fP"
.ti -1c
.RI "void \fBdvb_free_ts_tables\fP (struct \fBdvb_v5_descriptors\fP *\fBdvb_desc\fP)"
.br
.RI "\fIfrees a struct \fBdvb_v5_descriptors\fP \fP"
.ti -1c
.RI "struct \fBdvb_v5_descriptors\fP * \fBdvb_scan_transponder\fP (struct \fBdvb_v5_fe_parms\fP *parms, struct \fBdvb_entry\fP *entry, int dmx_fd, \fBcheck_frontend_t\fP *check_frontend, void *args, unsigned other_nit, unsigned timeout_multiply)"
.br
.RI "\fIScans a DVB dvb_add_scaned_transponder\&. \fP"
.ti -1c
.RI "void \fBdvb_add_scaned_transponders\fP (struct \fBdvb_v5_fe_parms\fP *parms, struct \fBdvb_v5_descriptors\fP *dvb_scan_handler, struct \fBdvb_entry\fP *first_entry, struct \fBdvb_entry\fP *entry)"
.br
.RI "\fIAdd new transponders to a \fBdvb_file\fP\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 

.SH "Typedef Documentation"
.PP 
.SS "typedef int( check_frontend_t) (void *args, struct \fBdvb_v5_fe_parms\fP *parms)"

.PP
Callback for the application to show the frontend status\&. 
.PP
\fBParameters:\fP
.RS 4
\fIargs\fP a pointer, opaque to libdvbv5, to be used by the application if needed\&. 
.br
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.RE
.PP

.PP
Definition at line 278 of file dvb\-scan\&.h\&.
.SH "Function Documentation"
.PP 
.SS "void dvb_add_scaned_transponders (struct \fBdvb_v5_fe_parms\fP * parms, struct \fBdvb_v5_descriptors\fP * dvb_scan_handler, struct \fBdvb_entry\fP * first_entry, struct \fBdvb_entry\fP * entry)"

.PP
Add new transponders to a \fBdvb_file\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.br
\fIdvb_scan_handler\fP pointer to a struct \fBdvb_v5_descriptors\fP containing scaned MPEG-TS 
.br
\fIfirst_entry\fP first entry of a DVB file struct 
.br
\fIentry\fP current entry on a DVB file struct
.RE
.PP
When the NIT table is parsed, some new transponders could be described inside\&. This function adds new entries to a \fBdvb_file\fP struct, pointing to those new transponders\&. It is used inside the scan loop, as shown at the \fBdvb_scan_transponder()\fP, to add new channels\&.
.PP
Example: 
.PP
.nf
1 for (entry = dvb_file->first_entry; entry != NULL; entry = entry->next) {
2      struct dvb_v5_descriptors *dvb_scan_handler = NULL;
3 
4      dvb_scan_handler = dvb_scan_transponder(parms, entry, dmx_fd,
5                                         &check_frontend, args,
6                                         args->other_nit,
7                                         args->timeout_multiply);
8      if (parms->abort) {
9         dvb_scan_free_handler_table(dvb_scan_handler);
10         break;
11      }
12      if (dvb_scan_handler) {
13         dvb_store_channel(&dvb_file_new, parms, dvb_scan_handler,
14                           args->get_detected, args->get_nit);
15         dvb_scan_free_handler_table(dvb_scan_handler);
16 
17         dvb_add_scaned_transponders(parms, dvb_scan_handler,
18                                     dvb_file->first_entry, entry);
19 
20         dvb_scan_free_handler_table(dvb_scan_handler);
21         }
22 }

.fi
.PP
 
.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP\&.
.SS "void dvb_free_ts_tables (struct \fBdvb_v5_descriptors\fP * dvb_desc)"

.PP
frees a struct \fBdvb_v5_descriptors\fP 
.PP
\fBParameters:\fP
.RS 4
\fI\fBdvb_desc\fP\fP pointed to the structure to be freed\&.
.RE
.PP
This function recursively frees everything that is allocated by \fBdvb_get_ts_tables()\fP and stored at \fBdvb_desc\fP, including \fBdvb_desc\fP itself\&. 
.SS "struct \fBdvb_v5_descriptors\fP* dvb_get_ts_tables (struct \fBdvb_v5_fe_parms\fP * parms, int dmx_fd, uint32_t delivery_system, unsigned other_nit, unsigned timeout_multiply)"

.PP
Scans a DVB stream, looking for the tables needed to identify the programs inside a MPEG-TS\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.br
\fIdmx_fd\fP an opened demux file descriptor 
.br
\fIdelivery_system\fP delivery system to be scanned 
.br
\fIother_nit\fP use alternate table IDs for NIT and other tables 
.br
\fItimeout_multiply\fP improves the timeout for each table reception by using a value that will multiply the wait time\&.
.RE
.PP
Given an opened frontend and demux, this function seeks for all programs available at the transport stream, and parses the following tables: PAT, PMT, NIT, SDT (and VCT, if the delivery system is ATSC)\&.
.PP
On sucess, it returns a pointer to a struct \fBdvb_v5_descriptors\fP, that can either be used to tune into a service or to be stored inside a file\&. 
.SS "int dvb_read_section (struct \fBdvb_v5_fe_parms\fP * parms, int dmx_fd, unsigned char tid, uint16_t pid, void ** table, unsigned timeout)"

.PP
read MPEG-TS tables that comes from a DTV card 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.br
\fIdmx_fd\fP an opened demux file descriptor 
.br
\fItid\fP Table ID 
.br
\fIpid\fP Program ID 
.br
\fItable\fP pointer to a pointer for the table struct to be filled 
.br
\fItimeout\fP Limit, in seconds, to read a MPEG-TS table
.RE
.PP
This function is used to read the DVB tables by specifying a table ID and a program ID\&. The libdvbv5 should have a parser for the descriptors of the table type that should be parsed\&. The table will be automatically allocated on success\&. The function will read on the specified demux and return when reading is done or an error has occurred\&. If table is not NULL after the call, it has to be freed with the apropriate free table function (even if an error has occurred)\&.
.PP
If the application wants to abort the read operation, it can change the value of parms->p\&.abort to 1\&.
.PP
Returns 0 on success or a negative error code\&.
.PP
Example usage: 
.PP
.nf
1 struct dvb_table_pat *pat;
2 int r = dvb_read_section( parms, dmx_fd, DVB_TABLE_PAT, DVB_TABLE_PAT_PID,
3                     (void **) &pat, 5 );
4 if (r < 0)
5      dvb_logerr("error reading PAT table");
6 else {
7      // do something with pat
8 }
9 if (pat)
10      dvb_table_pat_free( pat );

.fi
.PP
 
.SS "int dvb_read_section_with_id (struct \fBdvb_v5_fe_parms\fP * parms, int dmx_fd, unsigned char tid, uint16_t pid, int ts_id, void ** table, unsigned timeout)"

.PP
read MPEG-TS tables that comes from a DTV card with an specific table section ID 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.br
\fIdmx_fd\fP an opened demux file descriptor 
.br
\fItid\fP Table ID 
.br
\fIpid\fP Program ID 
.br
\fIts_id\fP Table section ID (for multisession filtering)\&. If no specific table section is needed, -1 should be used 
.br
\fItable\fP pointer to a pointer for the table struct to be filled 
.br
\fItimeout\fP limit, in seconds, to read a MPEG-TS table
.RE
.PP
This is a variant of \fBdvb_read_section()\fP that also seeks for an specific table section ID given by ts_id\&. 
.SS "int dvb_read_sections (struct \fBdvb_v5_fe_parms\fP * parms, int dmx_fd, struct \fBdvb_table_filter\fP * sect, unsigned timeout)"

.PP
read MPEG-TS tables that comes from a DTV card 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.br
\fIdmx_fd\fP an opened demux file descriptor 
.br
\fIsect\fP section filter pointer 
.br
\fItimeout\fP limit, in seconds, to read a MPEG-TS table
.RE
.PP
This is a variant of \fBdvb_read_section()\fP that uses a struct \fBdvb_table_filter\fP to specify the filter to use\&. 
.SS "struct \fBdvb_v5_descriptors\fP* dvb_scan_alloc_handler_table (uint32_t delivery_system)"

.PP
allocates a struct \fBdvb_v5_descriptors\fP 
.PP
\fBParameters:\fP
.RS 4
\fIdelivery_system\fP Delivery system to be used on the table
.RE
.PP
At success, returns a pointer\&. NULL otherwise\&. 
.SS "void dvb_scan_free_handler_table (struct \fBdvb_v5_descriptors\fP * dvb_scan_handler)"

.PP
frees a struct \fBdvb_v5_descriptors\fP 
.PP
\fBParameters:\fP
.RS 4
\fIdvb_scan_handler\fP pointer to the struct to be freed\&. 
.RE
.PP

.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP\&.
.SS "struct \fBdvb_v5_descriptors\fP* dvb_scan_transponder (struct \fBdvb_v5_fe_parms\fP * parms, struct \fBdvb_entry\fP * entry, int dmx_fd, \fBcheck_frontend_t\fP * check_frontend, void * args, unsigned other_nit, unsigned timeout_multiply)"

.PP
Scans a DVB dvb_add_scaned_transponder\&. 
.PP
\fBParameters:\fP
.RS 4
\fIparms\fP pointer to struct \fBdvb_v5_fe_parms\fP created when the frontend is opened 
.br
\fIentry\fP DVB file entry that corresponds to a transponder to be tuned 
.br
\fIdmx_fd\fP an opened demux file descriptor 
.br
\fIcheck_frontend\fP a pointer to a function that will show the frontend status while tuning into a transponder 
.br
\fIargs\fP a pointer, opaque to libdvbv5, that will be used when calling check_frontend\&. It should contain any parameters that could be needed by check_frontend\&. 
.br
\fIother_nit\fP Use alternate table IDs for NIT and other tables 
.br
\fItimeout_multiply\fP Improves the timeout for each table reception, by
.RE
.PP
This is the function that applications should use when doing a transponders scan\&. It does everything needed to fill the entries with DVB programs (virtual channels) and detect the PIDs associated with them\&.
.PP
A typical usage is to after open a channel file, open a dmx_fd and open a frontend\&. Then, seek for the MPEG tables on all the transponder frequencies with:
.PP
.PP
.nf
1 for (entry = dvb_file->first_entry; entry != NULL; entry = entry->next) {
2      struct dvb_v5_descriptors *dvb_scan_handler = NULL;
3 
4      dvb_scan_handler = dvb_scan_transponder(parms, entry, dmx_fd,
5                                         &check_frontend, args,
6                                         args->other_nit,
7                                         args->timeout_multiply);
8      if (parms->abort) {
9         dvb_scan_free_handler_table(dvb_scan_handler);
10         break;
11      }
12      if (dvb_scan_handler) {
13         dvb_store_channel(&dvb_file_new, parms, dvb_scan_handler,
14                           args->get_detected, args->get_nit);
15         dvb_scan_free_handler_table(dvb_scan_handler);
16         }
17 }
.fi
.PP
 
.PP
\fBExamples: \fP
.in +1c
\fBdvbv5\-scan\&.c\fP\&.
.SS "void dvb_table_filter_free (struct \fBdvb_table_filter\fP * sect)"

.PP
deallocates all data associated with a table filter 
.PP
\fBParameters:\fP
.RS 4
\fIsect\fP table filter pointer 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for libdvbv5 from the source code\&.
